---
title: "Task name: Short title"
output:
  html_document:
    df_print: paged
    toc: yes
    toc_float:
      collapsed: false
    toc_depth: 2
    number_sections: false
    smooth_scroll: false
    code_folding: hide
  pdf_document:
    latex_engine: xelatex
    toc: true
    toc_depth: 2
    number_sections: true
editor_options:
  chunk_output_type: inline
author: NM
date: "`r format(Sys.time(), '%d %B, %Y')`"
urlcolor: blue
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding, output_dir = "output/renders") })
---

## Libraries

`mmand` with examples: https://www.r-project.org/nosvn/pandoc/mmand.html

```{r}
# install.packages("mmand")
```


```{r setup, message=F}
knitr::opts_chunk$set(message = F)
knitr::opts_knit$set(root.dir = here::here())
# knitr::opts_chunk$set(cache = T)

library(utiles)
library(dplyr)
library(ggplot2)
# library(tidyr)
# library(purrr)
# library(plotly)
# library(renv)

library(mmand)
library(magick)
library(igraph)
```

<!-- your code -->

## Run cellid and load data

Run cellid:

```{r}
rcargs <- 
  rcell2::arguments("data/image_samples/", parameters = parameters.write(),
                    file.pattern = "^(BF|[A-Z]FP)_Position(\\d+)().tif$",
                    )
```


```{r}
rcell2::cell2(rcargs, cell.command = "~/Software/cellID-linux/cell", no_cores = 3, output_coords_to_tsv = T)
```

Load data:

```{r}
cell.data <- cell.load.alt("data/image_samples/", 
                           fluorescence.pattern = "^([A-Z]FP)_Position\\d+.tif$")

cell.boundaries <- cell.load.boundaries(data.source = "masks.tsv", arguments = rcargs)

image.data <- 
  cell.data$images %>% filter(!is.out, channel == "tfp") %>% 
    with(setNames(file, image)) %>% lapply(utiles::read_tif_to_matrix)

image.data.bf <- 
  cell.data$images %>% filter(!is.out, channel == "BF") %>% 
    with(setNames(file, image)) %>% lapply(utiles::read_tif_to_matrix)

pdata <- read.csv("data/image_samples/pdata.csv")
```

Take one sample image and a cell to play with:

```{r}
boundary.points <- 
  cell.boundaries %>% filter(pos == 1, cellID == 6) #%>% ggplot() + geom_tile(aes(x,y))

img.data.matrix <- 
  image.data$TFP_Position001.tif
  # image.data.bf$BF_Position001.tif

dim(img.data.matrix)

plot_matrix(img.data.matrix)
```


## `lm` based Hessian function

Should iterate over boundary pixels only:

```{r}
add_hessian_major_eigenvals <- function(boundary.points, img.data.matrix, w=4, neg_data=F){
  # w <- 4
  # x.range <- w:(dim(img.data.matrix)[1]-w)
  # y.range <- w:(dim(img.data.matrix)[2]-w)
  
  # boundary.point <- boundary.points[1,c("x", "y")]
  
  hessian.major.eigenvals <- 
    apply(X = boundary.points[,c("x", "y")], MARGIN = 1, FUN = function(boundary.point){
      x.pix <- boundary.point["x"]
      y.pix <- boundary.point["y"]
      # print(boundary.point)
      col.range <- (-w:w)+x.pix
      row.range <- (-w:w)+y.pix
      
      if( any(col.range < 1 | col.range > ncol(img.data.matrix)) ) return(NA)
      if( any(row.range < 1 | row.range > nrow(img.data.matrix)) ) return(NA)
      
      d <- img.data.matrix[row.range, col.range] %>% 
        utiles::ijtiff_to_df() %>% 
        dplyr::rename(z = pix_value)
      
      if(neg_data){d$z <- -d$z}
    
      d.lm <- lm(z ~ poly(x, degree = 2, raw = T) + poly(y, degree = 2, raw = T) + x*y, data = d)
      d.lm.s <- summary(d.lm)
      coef <- d.lm.s$coefficients[,1]
      names(coef) <- c("intercept", "x1", "x^2", "y1", "y^2", "xy")
      
      hessian <- matrix(byrow = T, ncol = 2, c(
        coef["x^2"], coef["xy"], 
        coef["xy"], coef["y^2"]
      ))
      
      major_eigenvalue <- eigen(hessian)$values[1]
      
      return(major_eigenvalue)
    })
  
  boundary.points$hessian <- hessian.major.eigenvals
  
  return(boundary.points)
}
```

Smooth pic:

```{r}
m.smooth <- mmand::gaussianSmooth(x = img.data.matrix, sigma = c(0.5,0.5))

dim(img.data.matrix) == dim(m.smooth)
```

Add hessian using the `lm` method and plot the result:

```{r}
boundary.points.h <- 
  cell.boundaries %>% filter(pos == 1) %>% 
  split(~ pos + cellID + t.frame) %>% 
  utiles::lapply_paralelo(add_hessian_major_eigenvals, m.smooth, par_packages = "dplyr", ncores = 8) %>% 
  bind_rows()

plot_matrix(m.smooth) +
  coord_cartesian(xlim = c(900,1200), ylim=c(0,250))

plot_matrix(m.smooth) +
  geom_point(aes(x,y,color=hessian), size=.2, data=boundary.points.h) + 
  scale_color_viridis_c() +
  coord_cartesian(xlim = c(900,1200), ylim=c(0,250))
```

## imager's imhessian function

Prepare input:

```{r}
boundary.points <- 
  cell.boundaries %>% filter(pos == 1)
```

Compute eigenvalues for boundary pixels:, keep the largest (is that the major? or is the first he major?):

```{r}
add_hessian_major_eigenvals2 <- function(boundary.points, img.data.matrix, #neg_data=F,
                                         only_boundary_eigenvalues=T, return_df=T){
  
  # Prepare input as 4D array:
  m.a <- array(img.data.matrix, dim = c(dim(img.data.matrix),1,1))
  
  # Compute hessian
  m.h <- imager::imhessian(m.a, axes = c("xx", "xy", "yy"))
  
  boundary.points$hessian <- NA_real_
  
  m.h.val <- function(k,j.row,i.col) m.h[[k]][j.row,i.col,1,1]
  m.h.vals <- Vectorize(m.h.val, vectorize.args = "k")
  
  if(only_boundary_eigenvalues){
    # Save boundary pixels eigenvalues only:
    m.h.eigen <- img.data.matrix
    m.h.eigen[,] <- NA
  
    for(i in 1:nrow(boundary.points)){
      i.col <- boundary.points$x[i]
      j.row <- boundary.points$y[i]
      
      hessian.mat <- matrix(data = m.h.vals(c(1,2,2,3),j.row,i.col),
                            byrow = T, ncol = 2)
      
      # major_eigenvalue <- eigen(hessian.mat)$values[1]
      major_eigenvalue <- max(eigen(hessian.mat)$values)
      m.h.eigen[j.row,i.col] <- major_eigenvalue
      
      boundary.points[i, "hessian"] <- major_eigenvalue
    }
    
    if(return_df)
      return(boundary.points)
    else
      return(m.h.eigen)
    
  } else {
    # Save all pixels eigenvalues:
    for(i.col in 1:ncol(m)) {
      for(j.row in 1:nrow(m)){

        hessian.mat <- matrix(byrow = T, ncol = 2, c(
          m.h[[1]][j.row,i.col], m.h[[2]][j.row,i.col],
          m.h[[2]][j.row,i.col], m.h[[3]][j.row,i.col]
        ))

        major_eigenvalue <- eigen(hessian.mat)$values[1]
        # major_eigenvalue <- max(eigen(hessian.mat)$values)

        m.h.eigen[j.row,i.col] <- major_eigenvalue
      }
    }

    if(return_df){
      df.h.eigen <- utiles::matrix_to_df(m.h.eigen) %>%
        dplyr::rename(hessian=pix_value)
      return(df.h.eigen)
    } else
      return(m.h.eigen)
  }
  
  stop("Si ves esto, algo anduvo mal en add_hessian_major_eigenvals2!")
}
```


```{r}
plot_matrix(m.smooth) +
  coord_cartesian(xlim = c(900,1200), ylim=c(0,250))

m.h.eigen.df <- add_hessian_major_eigenvals2(boundary.points = boundary.points, 
                                             img.data.matrix = -m.smooth)

plot_matrix(m.smooth) +
  geom_point(aes(x,y,color=hessian), size=.2, data=m.h.eigen.df) + 
  scale_color_viridis_c() +
  coord_cartesian(xlim = c(900,1200), ylim=c(0,250))
```

```{r}
hist(boundary.points.h$hessian )
hist(m.h.eigen.df$hessian)
```

```{r}
cdata.h <- 
  m.h.eigen.df %>% 
    group_by(pos, cellID, t.frame) %>% 
    summarise(he.mean = mean(hessian), he.sd = sd(hessian)) %>% 
    right_join(cell.data$data) %>% left_join(pdata)
```

```{r}
shinyCell(cdata.h, pdata, cell.data$images, launch.browser = "firefox")
```

