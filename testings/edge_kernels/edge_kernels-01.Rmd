---
title: "Edge Kernles for Cell-iD BFs"
---

```{r setup}
devtools::load_all("~/Projects/Academia/Colman/gitlabs_acl/utiles", reset = T)
# devtools::load_all("~/Projects/Academia/Colman/gitlabs_acl/rcell2", reset = T)
# devtools::install()
library(rcell2)
library(tidyverse)
```

## Ni idea de lo que estoy haciendo

* https://legacy.imagemagick.org/Usage/convolve/
* Andy: "Blob detection" https://www.cs.unc.edu/~lazebnik/spring11/lec08_blob.pdf
  * "Laplacian of Gaussian: Circularly symmetric operator for blob detection in 2D"
* https://opensky.ucar.edu/islandora/object/technotes%3A514/datastream/PDF/view
* https://rpubs.com/eR_ic/conv_pools
* http://meanmean.me/r/kernel/raster/2016/08/02/Kernels-for-everyone-!.html
  * https://www.r-bloggers.com/2016/08/kernels-for-everyone/
* https://ropensci.org/blog/2017/11/02/image-convolve/
* https://en.wikipedia.org/wiki/Blob_detection#Spatio-temporal_blob_detectors
* https://en.wikipedia.org/wiki/Ridge_detection
  * https://dsp.stackexchange.com/questions/1714/best-way-of-segmenting-veins-in-leaves
  * https://stackoverflow.com/questions/20297711/r-hessian-matrix

# Datos

```{r}
path <- "data/image_samples_classification/renamed/" %>% here::here()

parameters.txt <- parameters.write()

my_arguments <- 
  arguments(path = path,
            file.pattern = "(BF|YFP)_Position(\\d+)().tif", 
            parameters = parameters.txt)

cell.data <- cell.load.alt(path,
                           fluorescence.pattern = "^([GCYRT]FP|[GCYRT]\\d{2})_Position\\d+.tif$",)

cell.boundaries <- 
  cell.load.boundaries(data.source = "masks.tsv", 
                       arguments = my_arguments)

images <- cell.data$images
cdata <- readRDS("data/image_samples_classification/cdata.tree.RDS")

datos.k1 <- readRDS("data/image_samples_classification/datos.RDS") %>% 
  mutate(grupo = as.factor(grupo))
```

# DoG:0,0,2 on one cell

```{r}
one.ucid <- cdata[15,]$ucid
```


```{r}
img <- cdata %>% filter(ucid == one.ucid) %>% 
  magickCell(images, annotation_params = NULL, n.cells = 1, ch = "BF", return_raw = T)

img <- img %>% magick::image_convert("tiff", depth = 16, colorspace = "gray")

img %>% magick::image_write("BF.tif")

img %>% magick::image_normalize() %>% 
  magickForKnitr(.resize = "400x400") %>% knitr::include_graphics()
```

```{r}
# img %>% image_convolve('DoG:0,0,2') %>% image_negate() %>% image_normalize()
# img %>% image_convolve('DoG:0,0,2') %>% image_negate() %>% image_equalize()
# img %>% image_convolve('DoG:0,0,2') %>% image_normalize()
# img %>% image_convolve('DoG:0,0,2') %>% image_equalize()

c(img, img %>% magick::image_convolve('DoG:0,0,2') %>% magick::image_equalize())
```

## The Hessian / Ridge detection

```{r}
# https://opensky.ucar.edu/islandora/object/technotes%3A514/datastream/PDF/view
# install.packages("smoothie")

# img.data <- as.numeric(img[[1]])[,,1] * (65536 - 1)
img.data <- as.numeric(img[[1]])[,,1] * (256 - 1)
```

Segun SO, deberia conseguir el "Hessian" usando valores chiquitos de x e y,
a partir de parabolas. No se si lo que hice está bien...

* https://dsp.stackexchange.com/questions/1714/best-way-of-segmenting-veins-in-leaves

Esperaba sacar el Hessian de los coeficientes de un ajuste igual al del post en SO.
Peor ahí dice algo sobre usar un filtro gausiano u otro (y no entiendo qué hacer).

No parece estar tan mal mi aproximación:

```{r}
d <- img.data[1:5+30,1:5+40] %>% 
  utiles::ijtiff_to_df() %>% 
  dplyr::rename(z = pix_value)

# d.m <- lm(z ~ x^2 + y^2 + x*y + x + y, data = d)
d.lm <- lm(z ~ poly(x, degree = 2, raw = T) + poly(y, degree = 2, raw = T) + x*y, data = d)

d$z.pred <- predict(d.lm)

d.lm.s <- summary(d.lm)
# d.lm.s

coef <- d.lm.s$coefficients[,1]
names(coef) <- c("intercept", "x1", "x^2", "y1", "y^2", "xy")

coef

ggplot(d) + geom_tile(aes(x,y,fill=z-min(z)))
ggplot(d) + geom_tile(aes(x,y,fill=z.pred-min(z)))
ggplot(d) + geom_tile(aes(x,y,fill=z-z.pred))
```

```{r}
hessian <- matrix(byrow = T, ncol = 2, c(
  coef["x^2"], coef["xy"], 
  coef["xy"], coef["y^2"]
))

hessian
```

> To detect ridges, we want to find areas in the image that look like the last of the plots above, so we're looking for areas where the major eigenvalue of the Hessian is large (compared to the minor eigenvalue).
> 
> The simplest way to detect that is just to calculate the major eigenvalue at each pixel - and that's what the ridge filter below does.

* https://cran.r-project.org/web/packages/matlib/vignettes/eigen-ex1.html

```{r}
eigen(hessian)
```

```{r}
w <- 4
x.range <- w:(dim(img.data)[1]-w)
y.range <- w:(dim(img.data)[2]-w)

img.hessian <- matrix(nrow = dim(img.data)[1], ncol = dim(img.data)[2])

for(x.pix in x.range){
  for(y.pix in y.range){
    d <- img.data[(-w:w)+x.pix,(-w:w)+y.pix] %>% 
    utiles::ijtiff_to_df() %>% 
    dplyr::rename(z = pix_value)
  
    d.lm <- lm(z ~ poly(x, degree = 2, raw = T) + poly(y, degree = 2, raw = T) + x*y, data = d)
    d.lm.s <- summary(d.lm)
    coef <- d.lm.s$coefficients[,1]
    names(coef) <- c("intercept", "x1", "x^2", "y1", "y^2", "xy")
    
    hessian <- matrix(byrow = T, ncol = 2, c(
      coef["x^2"], coef["xy"], 
      coef["xy"], coef["y^2"]
    ))
    
    major_eigenvalue <- eigen(hessian)$values[1]
    
    img.hessian[x.pix,y.pix] <- major_eigenvalue
    
  }
}

img.data.df <- ijtiff_to_df(img.data)
img.hessian.df <- ijtiff_to_df(img.hessian) %>% rename(hessian = pix_value)
```


```{r}
img.data.df %>% 
  ggplot() + geom_tile(aes(x,y,fill=pix_value)) +
  scale_fill_gradient(low = "black", high = "white")

img.hessian.df %>% 
  ggplot() + geom_tile(aes(x,y,fill=hessian)) +
  scale_fill_viridis_c()

img.data.df %>% 
  ggplot() +
  geom_tile(aes(x,y,fill=pix_value)) +
  geom_point(aes(x,y,color=hessian), color = "red",
             data = img.hessian.df %>% filter(hessian > 0.5)
             ) +
  scale_fill_gradient(low = "black", high = "white") #+ scale_color_viridis_c()
```


```{r}
img.dog <- img.data %>% 
  smoothie::kernel2dsmooth(kernel.type = "gauss",
                           nx=10, ny=10, sigma=0.5) %>%
  smoothie::kernel2dsmooth(kernel.type = "LoG",
                           nx=7, ny=7, sigma=2)
img.dog <- 
  round((img.dog - min(img.dog))*(65536 - 1)/(max(img.dog)- min(img.dog))) %>% 
  as.matrix() %>% 
  # as.raster(max = (65536 - 1)) %>%
  as.raster(max = (256 - 1)) %>%
  magick::image_read() %>% 
  image_crop(geometry = "32x32+25+25") %>% 
  image_resize("100x100") %>% 
  image_normalize()

c(img %>% image_crop(geometry = "32x32+25+25") %>% 
  image_resize("100x100") %>% image_normalize, img.dog)
```


```{r}
img.dog %>% 
  image_crop(geometry = "32x32+25+25") %>% 
  image_write(path = "one.DoG.tiff", format = "tif")

img %>% image_crop(geometry = "32x32+25+25") %>% 
  image_write(path = "one.BF.tiff", format = "tif")
```

```{r}
out <- (h-2*sigma2)*exp(-h/(2*sigma2))/(sigma2^2)
out <- out - mean(out)
```

