---
title: "Edge Kernles for Cell-iD BFs"
---

```{r setup}
# devtools::load_all("~/Projects/Academia/Colman/gitlabs_acl/utiles", reset = T)
devtools::load_all(reset = T)
# devtools::install()
# library(rcell2)
library(utiles)
library(tidyverse)
```

## Ni idea de lo que estoy haciendo

* https://legacy.imagemagick.org/Usage/convolve/
* Andy: "Blob detection" https://www.cs.unc.edu/~lazebnik/spring11/lec08_blob.pdf
  * "Laplacian of Gaussian: Circularly symmetric operator for blob detection in 2D"
* https://opensky.ucar.edu/islandora/object/technotes%3A514/datastream/PDF/view
* https://rpubs.com/eR_ic/conv_pools
* http://meanmean.me/r/kernel/raster/2016/08/02/Kernels-for-everyone-!.html
  * https://www.r-bloggers.com/2016/08/kernels-for-everyone/
* https://ropensci.org/blog/2017/11/02/image-convolve/
* https://en.wikipedia.org/wiki/Blob_detection#Spatio-temporal_blob_detectors
* https://en.wikipedia.org/wiki/Ridge_detection
  * https://dsp.stackexchange.com/questions/1714/best-way-of-segmenting-veins-in-leaves
  * https://stackoverflow.com/questions/20297711/r-hessian-matrix

# Datos

```{r}
path <- "data/image_samples_classification/renamed/" %>% here::here()

parameters.txt <- parameters.write()

my_arguments <- 
  arguments(path = path,
            file.pattern = "(BF|YFP)_Position(\\d+)().tif", 
            parameters = parameters.txt)

cell.data <- cell.load.alt(path,
                           fluorescence.pattern = "^([GCYRT]FP|[GCYRT]\\d{2})_Position\\d+.tif$",)

cell.boundaries <- 
  cell.load.boundaries(data.source = "masks.tsv", 
                       arguments = my_arguments)

images <- cell.data$images
cdata <- readRDS("data/image_samples_classification/cdata.tree.RDS")

datos.k1 <- readRDS("data/image_samples_classification/datos.RDS") %>% 
  mutate(grupo = as.factor(grupo))
```

# magick DoG:0,0,2 on one cell

```{r}
one.ucid <- cdata[15,]$ucid

one.boundary <- cell.boundaries %>% 
  filter(cellID == cdata[15,]$cellID,
         pos == cdata[15,]$pos,
         t.frame == cdata[15,]$t.frame)
```


```{r}
img <- cdata %>% filter(ucid == one.ucid) %>% 
  magickCell(images, annotation_params = NULL, n.cells = 1, ch = "BF", return_raw = T)

img <- img %>% magick::image_convert("tiff", depth = 16, colorspace = "gray")

img %>% magick::image_write("BF.tif")

img %>% magick::image_normalize() %>% 
  magickForKnitr(.resize = "400x400") %>% knitr::include_graphics()
```

```{r}
img %>%
  magick::image_data() %>% as.numeric() %>% .[,,1] %>% ijtiff_to_df() %>% 
  ggplot() +
  geom_tile(aes(x,y,fill=pix_value)) + scale_fill_gradient(low = "black", high = "white")

img %>% magick::image_convolve('DoG:0,0,2', bias = "50%") %>% 
  magick::image_data() %>% as.numeric() %>% .[,,1] %>% ijtiff_to_df() %>% 
  ggplot() +
  geom_tile(aes(x,y,fill=pix_value)) + scale_fill_gradient(low = "black", high = "white")  

c(img, img %>% magick::image_convolve('DoG:0,0,2', bias = "50%") %>% magick::image_equalize())
```

### DoG mas grande para blob detection?

* https://legacy.imagemagick.org/Usage/convolve/#dog
* https://en.wikipedia.org/wiki/Blob_detection#The_difference_of_Gaussians_approach
* https://www.cs.princeton.edu/courses/archive/fall17/cos429/notes/cos429_fall2017_lecture4_interest_points.pdf

> This will generate a 'DoG' or "Difference of Gaussians" kernel in which the gaussian generated by 'sigma1' will have the gaussian generated by 'sigma2' subtracted from it.
> 
> Normally 'sigma2' is the larger so that the 'central peak' of the kernel is positive. Reversing the two numbers will effectivally negate the resulting kernel. 

$$ DoG:{radius},{sigma1}[,{sigma2}]$$

```{r}
img %>%
  magick::image_data() %>% as.numeric() %>% .[,,1] %>% ijtiff_to_df() %>% 
  ggplot() +
  geom_tile(aes(x,y,fill=pix_value)) + scale_fill_gradient(low = "black", high = "white")
```


```{r}
conv_kern <- 'DoG:0,0,2'
img %>% magick::image_convolve(conv_kern, bias = "50%") %>% 
  magick::image_data() %>% as.numeric() %>% .[,,1] %>% ijtiff_to_df() %>% 
  ggplot() +
  geom_tile(aes(x,y,fill=pix_value)) + scale_fill_gradient(low = "black", high = "white")
```

Por escala, un blob con radio "8" debería tener un sigma "8" también,
para ser detectado por LoG.

Dicen que hay que normalizar la respuesta del kernel por escala (sigma),
para poder comparar entre escalas.

Sin embargo, con `imagemagick` parece no ser necesario... siempre me da mas
respuesta normalizando (con `respuesta*sigma` o `respuesta*sigma^2`).

Así que no normalicé.

```{r, fig.height=10}
conv_kerns <- seq(from=2,to=10,by=0.1) %>% 
  {setNames(.,.)} %>% 
  lapply(function(x) list(sigma=x, kern=paste0('LoG:0,', x)))


logs <- 
  lapply(conv_kerns, function(conv_kern){
    img %>% 
      magick::image_crop(magick::geometry_area(40,40,20,0)) %>%
      magick::image_convolve(conv_kern$kern, bias = "50%") %>% 
      magick::image_data() %>% as.numeric() %>% .[,,1] %>% 
      ijtiff_to_df() %>% 
      mutate(response = pix_value * conv_kern$sigma) #%>% 
  }) %>% 
  bind_rows(.id="sigma") %>% 
  mutate(sigma = as.numeric(sigma))

logs %>% 
  # filter(sqrt((20-x)^2 + (19-y)^2) <= 6.2) %>% 
  ggplot() +
    geom_tile(aes(x,y,fill=pix_value)) +
    scale_fill_gradient(low = "black", high = "white") +
  facet_wrap(~sigma, ncol = 12) + coord_equal()
```

```{r}
logs %>%
  filter(sqrt((20-x)^2 + (20-y)^2) <= 6.2) %>% 
  # ggplot() + geom_density(aes(pix_value, group=sigma, color=sigma))
  # ggplot() + geom_boxplot(aes(x=as.factor(sigma), y=pix_value))
  # group_by(sigma) %>% summarise(response=median(pix_value, 0.70)) %>% 
  group_by(sigma) %>% summarise(response=mean(pix_value)) %>% 
  ggplot() + 
  geom_line(aes(x=sigma, y=response)) + 
  geom_vline(aes(xintercept = sigma[which.max(response)]), color="red") +
  geom_label(aes(x=sigma[which.max(response)], 
                 y=max(response), 
                 label=sigma[which.max(response)]))
```


```{r}
img %>%
  magick::image_data() %>% as.numeric() %>% .[,,1] %>% ijtiff_to_df() %>% 
  ggplot() +
  geom_tile(aes(x,y,fill=pix_value)) + scale_fill_gradient(low = "black", high = "white")

img %>% magick::image_convolve('DoG:0,0,2', bias = "50%") %>% 
  magick::image_data() %>% as.numeric() %>% .[,,1] %>% ijtiff_to_df() %>% 
  ggplot() +
  geom_tile(aes(x,y,fill=pix_value)) + scale_fill_gradient(low = "black", high = "white")  

c(img, img %>% magick::image_convolve('DoG:0,0,2', bias = "50%") %>% magick::image_equalize())
```

## The Hessian / Ridge detection

### Load image data

```{r}
# https://opensky.ucar.edu/islandora/object/technotes%3A514/datastream/PDF/view
# install.packages("smoothie")

# img.data <- as.numeric(img[[1]])[,,1] * (65536 - 1)
img.data <- as.numeric(img[[1]])[,,1] * (256 - 1)
```

### Build hessian with lm

Segun SO, deberia conseguir el "Hessian" usando valores chiquitos de x e y,
a partir de parabolas. No se si lo que hice está bien...

* https://dsp.stackexchange.com/questions/1714/best-way-of-segmenting-veins-in-leaves

Esperaba sacar el Hessian de los coeficientes de un ajuste igual al del post en SO.
Peor ahí dice algo sobre usar un filtro gausiano u otro (y no entiendo qué hacer).

No parece estar tan mal mi aproximación:

```{r}
d <- img.data[1:5+30,1:5+40] %>% 
  utiles::ijtiff_to_df() %>% 
  dplyr::rename(z = pix_value)

# d.m <- lm(z ~ x^2 + y^2 + x*y + x + y, data = d)
d.lm <- lm(z ~ poly(x, degree = 2, raw = T) + poly(y, degree = 2, raw = T) + x*y, data = d)

d$z.pred <- predict(d.lm)

d.lm.s <- summary(d.lm)
# d.lm.s

coef <- d.lm.s$coefficients[,1]
names(coef) <- c("intercept", "x1", "x^2", "y1", "y^2", "xy")

coef

ggplot(d) + geom_tile(aes(x,y,fill=z-min(z)))
ggplot(d) + geom_tile(aes(x,y,fill=z.pred-min(z)))
ggplot(d) + geom_tile(aes(x,y,fill=z-z.pred))
```

```{r}
hessian <- matrix(byrow = T, ncol = 2, c(
  coef["x^2"], coef["xy"], 
  coef["xy"], coef["y^2"]
))

hessian
```

### Get hessian eigenvalues

> To detect ridges, we want to find areas in the image that look like the last of the plots above, so we're looking for areas where the major eigenvalue of the Hessian is large (compared to the minor eigenvalue).
> 
> The simplest way to detect that is just to calculate the major eigenvalue at each pixel - and that's what the ridge filter below does.

* https://cran.r-project.org/web/packages/matlib/vignettes/eigen-ex1.html

```{r}
eigen(hessian)
```

### Compute for all points

```{r}
w <- 4
x.range <- w:(dim(img.data)[1]-w)
y.range <- w:(dim(img.data)[2]-w)

img.hessian <- matrix(nrow = dim(img.data)[1], ncol = dim(img.data)[2])

for(x.pix in x.range){
  for(y.pix in y.range){
    d <- img.data[(-w:w)+x.pix,(-w:w)+y.pix] %>% 
    utiles::ijtiff_to_df() %>% 
    dplyr::rename(z = pix_value)
  
    d.lm <- lm(z ~ poly(x, degree = 2, raw = T) + poly(y, degree = 2, raw = T) + x*y, data = d)
    d.lm.s <- summary(d.lm)
    coef <- d.lm.s$coefficients[,1]
    names(coef) <- c("intercept", "x1", "x^2", "y1", "y^2", "xy")
    
    hessian <- matrix(byrow = T, ncol = 2, c(
      coef["x^2"], coef["xy"], 
      coef["xy"], coef["y^2"]
    ))
    
    major_eigenvalue <- eigen(hessian)$values[1]
    
    img.hessian[x.pix,y.pix] <- major_eigenvalue
    
  }
}

img.data.df <- ijtiff_to_df(img.data)
img.hessian.df <- ijtiff_to_df(img.hessian) %>% rename(hessian = pix_value)
```

### Plot results

```{r}
img.data.df %>% 
  ggplot() + geom_tile(aes(x,y,fill=pix_value)) +
  scale_fill_gradient(low = "black", high = "white")

img.hessian.df %>% 
  ggplot() + geom_tile(aes(x,y,fill=hessian)) +
  scale_fill_viridis_c()

img.data.df %>% 
  ggplot() +
  geom_tile(aes(x,y,fill=pix_value)) +
  geom_point(aes(x,y,color=hessian), #color = "red",
             data = img.hessian.df #%>% filter(hessian > 0.5, x <60)
             ) +
  scale_fill_gradient(low = "black", high = "white") + scale_color_viridis_c()
```

Ahora hay que combinarlo con el boundary, pero eso esta en las coordenadas de la imagen BF, no en el "crop" de la celula:

```{r}
cdata %>% filter(ucid == one.ucid) %>% .[1,c("xpos", "ypos")] %>% unlist()
```

## Smooth and LoG 

```{r}
img.dog <- img.data %>% 
  smoothie::kernel2dsmooth(kernel.type = "gauss",
                           nx=10, ny=10, sigma=0.5) %>%
  smoothie::kernel2dsmooth(kernel.type = "LoG",
                           nx=7, ny=7, sigma=2)
img.dog <- 
  round((img.dog - min(img.dog))*(65536 - 1)/(max(img.dog)- min(img.dog))) %>% 
  as.matrix() %>% 
  # as.raster(max = (65536 - 1)) %>%
  as.raster(max = (256 - 1)) %>%
  magick::image_read() %>% 
  image_crop(geometry = "32x32+25+25") %>% 
  image_resize("100x100") %>% 
  image_normalize()

c(img %>% image_crop(geometry = "32x32+25+25") %>% 
  image_resize("100x100") %>% image_normalize, img.dog)
```


```{r}
img.dog %>% 
  image_crop(geometry = "32x32+25+25") %>% 
  image_write(path = "one.DoG.tiff", format = "tif")

img %>% image_crop(geometry = "32x32+25+25") %>% 
  image_write(path = "one.BF.tiff", format = "tif")
```

```{r}
out <- (h-2*sigma2)*exp(-h/(2*sigma2))/(sigma2^2)
out <- out - mean(out)
```

