---
title: "Edge erosion for Cell-ID masks"
---

```{r setup}
knitr::opts_chunk$set(message = F)
knitr::opts_knit$set(root.dir = here::here())
# knitr::opts_chunk$set(cache = T)

library(utiles)
library(dplyr)
library(ggplot2)
# library(tidyr)
# library(purrr)
# library(plotly)
# library(renv)

library(mmand)
library(magick)
library(igraph)
```


## Load data

```{r}
pics <- dir(path = "testings/erosion_dilation/test_imgs/", full.names = T, pattern = "tif")

pic_mats <- lapply(pics, read_tif_to_matrix)

# lapply(pic_mats, plot_matrix)
```

Me gusta el smooth con `sigma = c(0.5,0.5)`:

```{r}
m <- pic_mats[[2]]
m.smooth <- gaussianSmooth(x = m, sigma = c(0.5,0.5))
plot_matrix(m)
plot_matrix(m.smooth)
```


```{r}
k <- shapeKernel(width = rep(2,2), type="diamond")  #type = c("box", "disc", "diamond")

plot_matrix(m) + ggtitle("Original")
plot_matrix(erode(m,k)) + ggtitle("Erode")
plot_matrix(dilate(m,k)) + ggtitle("Dilate")

plot_matrix(m.smooth) + ggtitle("Smooth")
plot_matrix(erode(m.smooth,k)) + ggtitle("Smooth Erode")
plot_matrix(dilate(m.smooth,k)) + ggtitle("Smooth Dilate")

plot_matrix(dilate(m,k) - erode(m,k)) + ggtitle("DE over original matrix")
plot_matrix(dilate(m.smooth,k) - erode(m.smooth,k)) + ggtitle("DE over smooth matrix")
```

## Automata falopa v2

El problema de este es que en muchas geometrias de frontera,
el pixel del medio es un camino mas corto entre otros dos localmente

### Regla vecinos conectados

Kill

```{r}
m33 <- matrix(c(0,0,1,1,1,0,1,1,0), 3)
m33 <- matrix(c(0,0,0,1,1,0,1,1,0), 3)
plot_binary_matrix(m33)
```


```{r}
check_neighs <- function(m33, max_dist=sqrt(2)){
  m33[2,2] <- 0
  # plot_binary_matrix(m33)
  
  # If there are less than 2 neighbours, this one may be killed.
  if(sum(m33) < 2) return(TRUE)
  
  dists <- 
    matrix_to_df(m33) %>% filter(pix_value == 1) %>% select(-pix_value) %>% 
    dist() %>% as.matrix()
  dists
  
  diag(dists) <- NA
  # dists[upper.tri(dists)] <- NA
  dists
  
  closest_neigh_dist <- dists %>% apply(MARGIN = 2, function(x) min(x, na.rm=T))
  
  # If TRUE we *can* kill this pixel,
  # because neighbours do not depend on this one to be connected
  closest_neigh_dist.condition <- all(closest_neigh_dist <= max_dist)
  
  # ¿But should we kill it? A 1-filled matrix will say "you may kill"
  # Even though we should not kill it, obviously
  # To decide, I can use the erode function or check for the center's betweenness
  return(closest_neigh_dist.condition)
}

plot_binary_matrix(m33) + ggtitle("Delete?", check_neighs(m33))
```

Tambien queria chequear si el pixel del medio esta en un shortest path o no.

Si no lo estaba, no ayuda a conectar pixeles realmente, y se deberia borrar.

```{r}
m33.yes <- matrix(c(1,0,0,1,1,0,1,0,0), 3)
m33.no <- matrix(c(0,1,0,0,1,1,0,1,0), 3)
# plot_binary_matrix(m33)

weighted_shortest_paths.condition <- function(allpaths, v){
  sapply(allpaths, function(p) v %in% p) %>% any()
}

has.weighted_shortest_paths <- function(cgraph, 
                                        v=which(V(cgraph)$coords == "2,2"),
                                        condition.function=weighted_shortest_paths.condition){
  #initialize a list to populate with all the shortest paths in the graphy
  # allpaths <- c()
  allpaths <- list()
  
  n.verts <- 1:length(V(cgraph))
  
  #Assuming this is an undirected graph, we don't want to calculate both a %--% b and b %--% a  
  for(i in n.verts){
    for(j in n.verts){
      if(i != v & j != v & i < j){
        shortest_path_options <- all_shortest_paths(cgraph, i, j)$res
        #sometimes there are multiple shortest paths, we will include them all
        # allpaths <- append(allpaths, sum(sapply(shortest_path_options, length)))
        allpaths <- append(allpaths, shortest_path_options)
      }
    }
  }
  
  condition <- condition.function(allpaths, v)
  
  return(condition)
}



check_path <- function(m33, max_dist=sqrt(2)){
  # plot_binary_matrix(m33)
  
  xy <- matrix_to_df(m33) %>% 
    filter(pix_value > 0) %>% 
    select(x,y)
  
  dmat <- as.matrix(
    dist(xy, upper = T, diag = T)
  )
  
  # cmat <- dmat <= max_dist
  
  dmat[dmat > max_dist] <- 0
  cmat <- dmat
  
  cgraph <- igraph::graph.adjacency(cmat, mode = "undirected", diag = F, 
                                    weighted = "weight",
                                    add.colnames = "id"
                                    )
  V(cgraph)$coords <- apply(xy,1,paste,collapse=",")
  V(cgraph)$color <- ifelse(V(cgraph)$coords == "2,2", "lightblue", "orange")
  # plot.igraph(cgraph, edge.color=E(cgraph)$weight*10, edge.width=E(cgraph)$weight*10)
  
  # TRUE ~ Can kill
  # FALSE ~ Do not kill
  condition <- !has.weighted_shortest_paths(cgraph)
  # center_betweenness <- betweenness(cgraph, V(cgraph)[V(cgraph)$coords == "2,2"])
  # center_betweenness.condition <- center_betweenness == 0
  
  return(condition)
}

plot_binary_matrix(m33.yes) + ggtitle("Delete m33.yes?", check_path(m33.yes))
plot_binary_matrix(m33.no) + ggtitle("Delete m33.no?", check_path(m33.no))
```

```{r}
# c.nodes <- vertex_attr(cgraph) %>% as.data.frame()
# c.edges <- as.data.frame(igraph::ends(cgraph, es = E(cgraph)))
# c.edges[,3] <- edge_attr(cgraph)$weight
# names(c.edges) <- c("from", "to", "weight")
# 
# c.nodes
# c.edges
```


```{r}
# abs_betweenness <- function(x){
#   temp_bool <- sapply(allpaths, function(y){
#     (x %in% y) & (head(y, 1) != x) & (tail(y, 1) != x)
#   })
#   length(allpaths[temp_bool])
# }
# 
# abs_betweenness()
```


### Integración de reglas

```{r}
rules_3x3 <- function(m33, kill_val=0.5, dead_val=0, alive_val=1, no_rule_val = -1,
                      default_val = m33[2,2]){
  
  plot_binary_matrix(m33)
  stopifnot(dim(m33) == c(3,3))
  
  if(m33[2,2] == dead_val) return(dead_val)
  
  if(any(is.na(m33))) return(default_val)
  
  kill.conditon <- check_path(m33) & check_neighs(m33)
  
  result <- ifelse(kill.conditon, kill_val, alive_val)
  
  return(result)
}
```

## Iterador de autómata falopa

Get square by center coordinate:

```{r}
get_3x3 <- function(m,i.row=2,j.col=2){
  
  if(i.row < 2) stop("Indexes for rows and columns must be 2 or greater.")
  if(j.col < 2) stop("Indexes for rows and columns must be 2 or greater.")
  
  m[(i.row-1):(i.row+1), (j.col-1):(j.col+1)]
}
```


```{r}
conway_erode <- function(mask, kill_val = 0.5, no_rule_val = -1){
  mask.result <- mask
  mask.paded <- mat_pad(mask)
  
  # i.row <- 2
  # j.col <- 6
  
  for(i.row in 1:dim(mask)[1]){
    for(j.col in 1:dim(mask)[2]){
      
      # print(paste(i.row, j.col))
      
      mat_3x3 <- get_3x3(m = mask.paded, 
                         i.row = i.row+1, 
                         j.col = j.col+1)
      
      mask.result[i.row, j.col] <- rules_3x3(m33 = mat_3x3, 
                                             kill_val = kill_val)
        
    } 
  }
  
  return(mask.result)
}
```

## Other 8x8 tests

### Test 2: more patterns

```{r}
mask <- utiles::read_tif_to_matrix("testings/edge_kernels/8pix.tif", binarize = T)
plot_binary_matrix(mask)

mask.result <- conway_erode(mask)

# plot_binary_matrix(mat_pad(mask))
plot_binary_matrix(mask.result)
```


```{r}
mask <- utiles::read_tif_to_matrix("testings/edge_kernels/8pix_001.tif", binarize = T)

mask.result <- conway_erode(mask)

plot_binary_matrix(mat_pad(mask))
plot_binary_matrix(mask.result)
```

```{r}
mask <- utiles::read_tif_to_matrix("testings/edge_kernels/8pix_006.tif", binarize = T)

mask.result <- conway_erode(mask)

plot_binary_matrix(mat_pad(mask))
plot_binary_matrix(mask.result)
```

```{r}
mask <- utiles::read_tif_to_matrix("testings/edge_kernels/8pix_002.tif", binarize = T)
mask.result <- conway_erode(mask)

plot_binary_matrix(mat_pad(mask))
plot_binary_matrix(mask.result)
```

```{r}
mask <- utiles::read_tif_to_matrix("testings/edge_kernels/8pix_003.tif", binarize = T)

mask.result <- conway_erode(mask)

plot_binary_matrix(mask)
plot_binary_matrix(mask.result)
```

```{r}
mask <- utiles::read_tif_to_matrix("testings/edge_kernels/8pix_004.tif", binarize = T)

mask.result <- conway_erode(mask)

plot_binary_matrix(mask)
plot_binary_matrix(mask.result)
```

```{r}
mask <- utiles::read_tif_to_matrix("testings/edge_kernels/8pix_005.tif", binarize = T)

mask.result <- conway_erode(mask)

plot_binary_matrix(mask)
plot_binary_matrix(mask.result)
```

### Test 3: iteration

```{r}
mask <- utiles::read_tif_to_matrix("testings/edge_kernels/8pix.tif", binarize = T)

iterate_erode <- function(mask, ..., .dir=tempdir()){
  
  if(file.exists(.dir)) unlink(.dir, recursive = T)
  dir.create(.dir, showWarnings = F, recursive = T)
  
  png(filename = tempfile(pattern = paste(0, "-mask"), tmpdir = .dir, fileext = ".png"))
  print(plot_binary_matrix(mask))
  dev.off()

  for(i in 1:10){
    mask.post <- conway_erode(mask, kill_val = 0, no_rule_val = "center", ...)
    
    if(identical(mask, mask.post)){
      break
    } else {
      png(filename = tempfile(pattern = paste(i, "-mask"), tmpdir = .dir, fileext = ".png"))
      print(plot_binary_matrix(mask.post))
      dev.off()
      
      mask <- mask.post
    }
  }
}

iterate_erode(mask, .dir = "/tmp/test1")

knitr::include_graphics(dir("/tmp/test1", full.names = T))
```

```{r}
mask <- utiles::read_tif_to_matrix("testings/edge_kernels/48pix.tif", binarize = T)

iterate_erode <- function(mask, ..., .dir=tempdir()){
  
  if(file.exists(.dir)) unlink(.dir, recursive = T)
  dir.create(.dir, showWarnings = F, recursive = T)
  
  # png(filename = tempfile(pattern = paste(0, "-mask"), tmpdir = .dir, fileext = ".png"))
  print(plot_binary_matrix(mask))
  # dev.off()

  for(i in 1:10){
    mask.post <- conway_erode(mask, kill_val = 0, no_rule_val = "center", ...)
    
    if(identical(mask, mask.post)){
      break
    } else {
      # png(filename = tempfile(pattern = paste(i, "-mask"), tmpdir = .dir, fileext = ".png"))
      print(plot_binary_matrix(mask.post))
      # dev.off()
      
      mask <- mask.post
    }
  }
}

iterate_erode(mask, .dir = "/tmp/test2")

knitr::include_graphics(dir("/tmp/test2", full.names = T))
```


```{r}
mask <- utiles::read_tif_to_matrix("testings/edge_kernels/8pix_001.tif", binarize = T)
iterate_erode(mask)
```

```{r}
mask <- utiles::read_tif_to_matrix("testings/edge_kernels/8pix_002.tif", binarize = T)
iterate_erode(mask)
```

```{r}
mask <- utiles::read_tif_to_matrix("testings/edge_kernels/8pix_003.tif", binarize = T)
iterate_erode(mask)
```

```{r}
mask <- utiles::read_tif_to_matrix("testings/edge_kernels/8pix_004.tif", binarize = T)
iterate_erode(mask)
```

```{r}
mask <- utiles::read_tif_to_matrix("testings/edge_kernels/8pix_005.tif", binarize = T)
iterate_erode(mask)
```

## Proxima idea

* Buscar el patron 101 / 1001 / 10001 / etc. en la secuencia de ir alrededor al pixel central, para encontrar si el pixel del medio conecta dos pixeles de alrededor.
* Si se muere, pasar la vida al de al lado (ojo con oscilaciones, debe haber un criterio de terminacion, quizas decir que con un poquito de vida queda totalmente vivo para la comparación con la iteracion anterior).
