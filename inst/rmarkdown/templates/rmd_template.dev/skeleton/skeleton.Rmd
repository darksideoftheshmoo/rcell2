---
title: "rcell2: Workflow Template"
author: "Nicolás Méndez"
output:
  html_document:
    df_print: paged
    toc: yes
    toc_float:
      collapsed: false
    toc_depth: 4
    number_sections: false
    smooth_scroll: false
    code_folding: hide
  pdf_document:
    latex_engine: xelatex
    toc: true
    toc_depth: 4
    number_sections: true
date: "`r format(Sys.time(), '%d %B, %Y')`"
urlcolor: blue
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding, output_dir = "output/renders") })
bibliography: references.bib
---

<!-- Download a copy of this file with rcell2::get_workflow_template() -->

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = T,
                      message = F, 
                      # https://yihui.org/knitr/options/#chunk-options
                      out.width = "100%")
                      # https://stackoverflow.com/a/66753995
                      # tidy.opts = list(width.cutoff = 60), tidy = TRUE)
knitr::opts_knit$set(root.dir = here::here())  #, base.dir = here::here())

library(rcell2)  # this package you are checking out :)
# library(rcell2.cellid)  # Advanced functionality: run CellID entirely in R.
# library(rcell2.magick)  # Advanced functionality: filter data using Shiny and preview images with Magick.

# library(magick)  # if you need it

library(tidyverse)  # import numpy as np (?)
```

## Friendly reminders

- **Read the help page** of functions before using them. Open help pages with R's `?` (e.g. `?load_cell_data`).
- **Read the README**.md at rcell2's [GitHub repo](https://github.com/darksideoftheshmoo/rcell2/).

## Preamble

### Image file names

Images are assumed to be in a single directory, and have names with identifiers for:

* Imaging channel (birghtfield, transmission, fluorescence, z-slice, etc.).
* Microscope position (*pos*).
* Time (*t.frame*, optional).

Cell-ID uses the first 3 letters of the file name to group imaging channels.
**This is mandatory**. If your image set does not conform initially, it can be
renamed (or symlinked) using rcell2's `rename_mda`, with custom arguments.

For example, file names for a 2-position time course experiment
are expected to have the following appearance:

```
BF_Position001_time01.tif
BF_Position001_time02.tif
TFP_Position001_time01.tif
TFP_Position001_time02.tif
YFP_Position001_time01.tif
YFP_Position001_time02.tif
BF_Position002_time01.tif
BF_Position002_time02.tif
TFP_Position002_time01.tif
TFP_Position002_time02.tif
YFP_Position002_time01.tif
YFP_Position002_time02.tif
```

The `rcell2` packages rely on regular expressions to gather images and extract 
metadata from their file names (i.e. channel, position, and time frame.)

The file list will be recognized by a specific regular expression (regex).
A regex matching these files can be `^(BF|TFP)_Position(\\d+)_time(\\d+).tif$`;
note that it has **3 capturing groups** (suff between parentheses).
The regex as a whole is used to select images from a directory (filtering out
other files) and the capturing groups are used to extract the metadata.

### Renaming images

Your imaging software may use file names different from the usual style
(i.e `YFP_Position01_time1.tif`, and so on).

`rename_mda`, provided by the `rcell2.cellid` package, will help you rename
those weird file names into something more compatible with `rcell2`'s 
defailts.

### Check XY stage coordinates

It may be a good idea to check that the physical coordinates of your images
match your expectations (i.e. the column/row pairs of each well in a microscopy plate).
This information is stored in TIFF's metadata.

With this information it is also possible to check whether the fields of view of
different positions overlap, inadvertently.

Code for this check is available in the template notebook of the `rcell2.cellid` package.

Uncomment and execute the following to install the package and open the template:

```{r, eval=F}
# if(!requireNamespace("rcell2.cellid")) remotes::install_github("darksideoftheshmoo/rcell2-cellid")

# rcell2.cellid::get_workflow_template_cellid()
```

## Data sources

Set the `data_dir` variable to the path of your segmentation output:

```{r}
data_dir <- "/.../path/to/your/segmeted/images"
```

A full explanation and walkthrough of the image segmentation process is available
in the notebook template of the `rcell2.cellid` package.

Uncomment and execute the following to install the package and open the template:

```{r, eval=F}
# if(!requireNamespace("rcell2.cellid")) remotes::install_github("darksideoftheshmoo/rcell2-cellid")

# rcell2.cellid::get_workflow_template_cellid()
```

Uncomment and execute the following to install the examples package and set the data directory:

```{r, eval=F}
# if(!requireNamespace("remotes")) install.packages("remotes")
# if(!requireNamespace("rcell2.examples")) remotes::install_github("darksideoftheshmoo/rcell2.examples")

data_dir <- system.file("extdata/sample_datasets/sample_time_series/", package = "rcell2.examples")
```

The example data has already been process with `rcell2.cellid`.

## Load Cell-ID output

Cell-ID's output consists of segmented images, and data files in plain text format.
These must be loaded into R for further analyses.

This is done with the `load_cell_data` function:

```{r}
cell.data <- rcell2::load_cell_data(path = data_dir)
```

Alternativley, there is also the `get_cell_data` function from the `rcell2.cellid` package:

```{r}
cell.data <- rcell2.cellid::get_cell_data(path = data_dir)
```

> Obs: your `fluorescence.pattern` regex may vary, see `?get_cell_data`.

If Cell-ID was configured to output the segmentation mask, either to a TSV
or masked TIFF file, the information can be loaded with the `cell.load.boundaries`
function:

```{r}
cell.load.boundaries(data.source = "masks.tsv")
```

### Cell-ID variables

Descriptions of the variables in `cdata` are available in the `rcell2.cellid` package:

```{r eval=F}
rcell2.cellid::cellid_output_descriptions(F)
```

## Data anlysis

The cell.data object is a list. The main dataset is stored in the `data` item, and
the paths to image files are in the `images` item.

We usually assign these to their own objects, for easier manipulation:

```{r}
cdata <- cell.data$data
images <- cell.data$images
```

### Add stage position metadata

> **Warning**: `load_cell_data` does the following automatically if a pdata.csv file is 
found next to the images.
> If it were the case, you musnt't run the join again.

Load "pdata":

```{r}
# Set the path to the file (modify accodringly).
pdata_path <- "/.../somewhere/over/the/pdata.csv"

# It is a "metadata" dataframe we usually join to cdata by "position" and/or "t.frame",
# which contains other experimental variables: simuli concentrations, notes, etc.
pdata <- readr::read_csv(pdata_path)

pdata
```

> Note: the "p" in "pdata" stands for microscope _position_ data.

This table is usually joined to cdata by position (and time frame if available).

```{r eval=F}
cdata <- left_join(cdata, pdata)
```

<!-- ### Tidy framework -->

<!-- - [ ] TO-DO -->

### Shiny-Magick framework

Extra tools for graphical filtering and annotation/tagging are available in 
the `rcell2.magick` package.

That package also includes functions for generating and manipulating
images of single cells, and preparing strips, tiles, and plots.

To learn more, install the `rcell2.magick` package and open it's template notebook.

Uncomment and execute the following to install the package and open the template:

```{r}
# if(!requireNamespace("rcell2.magick")) remotes::install_github("darksideoftheshmoo/rcell2-magick")

# rcell2.magick::get_workflow_template_magick()
```

### Cell-tagging using ImageJ/FIJI

No analysis package exists (yet) that can replace a researcher's general visual assesment.

The `tagCell` function can provide a randomized experimental context 
for tagging (i.e. a _pseudo_ double-blind experiment).

If bias during tagging is not a concern, the "multi-point" tool in ImageJ can
be used to mark cells with different "counters", by simply clicking on them.

These marks can be exported and mapped back to ucids in R, and then
used for analysis.

#### Hyperstack ImageJ macro

This section helps you open your images with FIJI-ImageJ before you begin.

A simple Macro can be run in ImageJ to load virtual hyperstacks of any experiment.

> Note: this macro uses a "file" pattern that only matches input images (and not ".out")
> in a tipically-named set of images. Customize the pattern to your need.

Steps:

1. Run the following code, copy its output to the clipboard.
2. Open ImageJ/FIJI, and open a new "Macro" window by clicking on "Plugins -> New -> Macro".
3. Paste the macro into the macro editor, and click on "Run". A new hyperstack window will open.
4. Browse the images using the sliders.

```{r}
rcell2.cellid::ijm_open_hyperstack(images)
```

> Note: the files are symlinked with new names to a temporary directory. Otherwise, 
the names of the ImageJ dimensions may be mismatched between R and the macro. This is because 
virtual stacks must be in `xyczt` order (time is likely to end up as the "channels" dimension), 
but the order in which the "Image Sequence..." is loaded depends on how their files are named.

The only restriction of this approach is that only "3" dimensions are available for
browsing: `frame`, `plane`, and `channel`. This is relevant if you wish to browse
segmentation results (which adds another dimension to the set: original vs "out").
A fourth dimension would be needed, but Hyperstacks only provide 3. Alternatively, 
open another virtual hyperstack for the output images, and browse them in-sync.

#### Filtering multipoints

Steps (continued): read these steps before tagging.

5. Use the multi-point tool to mark individual cells with one or more "counters".
  - It is critical that you remember the which values of the "Ch" (channel), 
    "Slice", and "Frame" ImageJ measurements map to `t.frame`s, `pos`, and `ch`
    in Cell-IDs output.
  - Note that ImageJ's indexes begin at 1, but Cell-ID's begin at 0. This is
    specially relevant for `t.frame`s.
6. After tagging the positions make measurements (press Ctrl+M) and save
   the output to a `.csv` file.
7. Prepare a `data.frame` with tag names mapped to _Counter_ indices.
  - Note that ImageJ's Multi-point counters begin at 0.

Each "Counter" has an associated "tag", corresponding to the event or class
marked in the images.

```{r}
tag_descriptions <- c("Ok", "Budding", "Dead", "Spurious")

counter.desc.df <- data.frame(
  Counter = 0:3,
  tag_description = tag_descriptions
)

counter.desc.df
```

8. Prepare a `data.frame` relating _Slice_ indices to stage position indices.
  - Note that ImageJ's _Slices_ begin at 1.

```{r}
slice.pos.df <- data.frame(
  Slice = 1:2,
  pos = c(4,12)
)

slice.pos.df
```

9. Prepare a `data.frame` relating _Ch_ indices to `t.frame` position indices.
  - Note that ImageJ's _Ch_ begin at 1, and Cell-ID's `t.frame`s begin at 0.

```{r}
ch.frame.df <- data.frame(
  Ch = 1:3,
  t.frame = 0:2
)

ch.frame.df
```

9. Load the Multi-point tags.

We usually prepare one CSV file per position, and extract the position index
from the file name when loading the measurements into R.
For example, we CSV files saved as `pos01_filter.csv` (for position 1).

List CSV files:

```{r}
mp.filters.files <- dir(path = results.dir, 
                        pattern = "pos\\d+_filter.csv", 
                        full.names = T)

mp.filters.files
```

Load the tags, and extract the position index from the file's names:

```{r}
mp.filters <- 
  # Load CSV files
  mp.filters.files %>% 
  {lapply(setNames(., basename(.)), read_csv)} %>% 
  # Bind rows
  bind_rows(.id = "file") %>% 
  # Get position info
  extract(file, "pos(\\d+)_", into = "pos", convert = T) %>% 
  # Cleanup
  select(pos, X, Y, Ch, Slice, Frame) %>% 
  # Add an ID to each tag
  mutate(mpid = 1:n())

mp.filters
```

10. Reindex the time frame column to match Cell-ID's.

```{r}
mp.filters <- 
  # Re-index t.frame
  mutate(t.frame = t.frame - 1)
```

11. Examine the result.

```{r}
mp.filters
```

> Reminder: this is needed because virtual hyperstacks can only load images in "xyczt" order.

Here is an example `mp.filters` `data.frame`. In this case the position 
is encoded in the _Slice_ variable.

```{r}
mp.filters.file <- system.file("extdata/sample_datasets/sample_time_series/imagej_mp_tags/results_pos4_12.csv",
                               package = "rcell2.examples", mustWork = T)

multipoints <- 
  # Load CSV files
  mp.filters.file %>% read_csv() %>% 
  # Cleanup
  select(X, Y, Ch, Slice, Frame, Counter) %>% 
  # Add an ID to each tag
  mutate(mpid = 1:n())

mp.filters <- multipoints %>% 
  left_join(slice.pos.df) %>% 
  left_join(ch.frame.df) %>% 
  left_join(counter.desc.df)

mp.filters
```


#### Mapping to cdata

This procedure must be repeated for each _Counter_ type, only one example is shown below.
Happy copy-pasting.

Keep the first markers only:

```{r}
mp.filter <- mp.filters %>% filter(Counter == 0) %>% 
  select(mpid, X, Y, pos, tag_description, Counter, Slice)

mp.filter
```

Calculate distance to closest multipoint and save it's ID:

* Consider only multipoints in bounding box.
* Use counters for rtcc (0) and cycling (1).

```{r}
# Make a copy of cdata
cdata.mp <- cdata %>%
  filter(t.frame == min(t.frame)) %>% 
  select(ucid, pos, t.frame, xpos, ypos)

# Add the columns
cdata.mp[, c("closest.mp", "closest.mp.id")] <-
  apply(cdata.mp, 1, function(x){
    mp.pos <- filter(mp.filter, pos == x["pos"])
    
    if(nrow(mp.pos) == 0){
      return(c(closest.mp.drop=NA,
               closest.mp.drop.id=NA))
    }
    
    dists <- sqrt(( (x["xpos"]-mp.pos$X)^2) + ((x["ypos"]-mp.pos$Y)^2) )
    
    if(length(dists) == 0){
      return(c(closest.mp.drop=NA,
               closest.mp.drop.id=NA))
    }
    
    min.id <- mp.pos$mpid[which.min(dists)]
    
    c( min(dists), min.id)
  }) %>% t()
```

Set a threshold distance, and save the filter:

```{r}
cdata.mp$has.close.mp <- cdata.mp$closest.mp < 7.5
```

Plot result:

```{r}
p <- ggplot() + 
  geom_point(aes(xpos, ypos, 
                 color="CellID",
                 text=paste("ucid:", ucid, ", closest dist:", closest.mp)),
             data=cdata.mp) +
  
  geom_point(aes(X, Y, color="ImageJ"), 
             data = mp.filter, 
             size = 3) +
  
  geom_point(aes(xpos, ypos, color="matched"),
             data=cdata.mp %>% filter(has.close.mp)) +
  
  facet_wrap(~pos) + coord_equal() +
  ggtitle("Examine MP ilter result", 
          "black: imagej points, gray: all Cell-ID cells, red: Cell-ID cells matched to a point.") + 
  
  scale_color_manual(values=c(ImageJ="black", matched="red", CellID="grey")) +
  scale_y_reverse()

plotly::ggplotly(p)
```

#### Check for duplicated IDs

Generate indicator column:

```{r}
cdata.mp$n_dupes <- apply(X = cdata.mp, MARGIN = 1, function(cell){
  sum( (cell["closest.mp.id"] == cdata.mp$closest.mp.id) & cdata.mp$has.close.mp )
})

cdata.mp$dupes <- cdata.mp$n_dupes > 1

any(cdata.mp$dupes) # Should be false
unique(cdata.mp$n_dupes) # Should be only 1's
```

> `n_dupes` is 1 if the `ucid` was assigned to 1 mpid. If greater than 1,
> the `ucid` shares the mpid with at least anoher `ucid` (and this should
> not happen).

Check graphically:

```{r}
plt.dupes <- ggplot() + 
  
  geom_point(aes(X, Y), color = "gray",
             data = mp.filter %>% filter(Counter == 0), 
             size =3) +
  
  geom_point(aes(xpos, ypos), color = "black", data = cdata.mp) +

  geom_point(aes(xpos, ypos, color=as.factor(n_dupes)),
             data = cdata.mp %>% filter(has.close.mp)) + 
    
  geom_line(aes(xpos, ypos, group=closest.mp.id), color = "black",
            data = cdata.mp %>% filter(has.close.mp)) + 
  
  ggtitle("Graphical check of unique matches",
          "The points from cdata sharing a close multipoint are joined by lines") +
  
  facet_wrap(~pos)

plotly::ggplotly(plt.dupes)
```

Tabular check:f for each `closest.mp.drop.id` there should be only one row.

```{r}
chequeo.df <- cdata.mp %>% 
  group_by(closest.mp.id) %>% 
  filter(has.close.mp) %>% 
  summarise(row.count = n()) %>% 
  arrange(-row.count)

all(chequeo.df$row.count == 1)
```

```{r}
chequeo.df
```

#### Filter cdata

Use the ImageJ points to select cells in cdata.

Generate a mapping `data.frame`:

```{r}
mapping <- cdata.mp %>% filter(has.close.mp) %>% 
  select(ucid, closest.mp.id)
```

Last check for unicity:

```{r}
stopifnot(nrow(mapping) == nrow(unique(mapping)))
```

Examine:

```{r}
mapping
```

You can use this information to filter `cdata`, for example by `ucid`:

```{r}
cdata.filtered <- cdata %>% 
  filter(ucid %in% mapping$ucid)
```

Done! `cdata.filtered` now contains only cells that were matched to a `0` _Counter_
in ImageJ. Other uses for this include tagging events, or phenotypes of interest.

Optionally use `rcell2.magick` to display some images:

```{r}
cdata.filtered %>% 
  rcell2.magick::magickCell(images) %>% 
  rcell2.magick::magickForKnitr()
```


Repeat these steps for the other Multi-point _Counters_.

### Hu Moments

The Hu Moments can be computed from the masked TIFF files, generated by Cell-ID with 
the appropriate options (see `encode_cellID_in_pixels` and `fill_interior_pixels` in
the help page of `rcell2.cellid::cell2`).

To append the Hu Moments to a cell data object, use the `append_hues` function:

```{r}
cell_data <- rcell2::append_hues(cell_data = cell_data, 
                                 return_points = T, 
                                 image_bits = 16)

rcell2:::check_tiff_mask(cell_data)
```

Alternatively, the Hu Moments can be computed from the TSV files (see `output_coords_to_tsv`
at the help page of `rcell2.cellid::cell2`), by using the `append_hues2`.

Read its help page for more information:

```{r}
?append_hues2
```

